<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · CryptoTools.jl</title><link rel="canonical" href="https://Maelstrom6.github.io/CryptoTools.jl/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CryptoTools.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Maelstrom6/CryptoTools.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="CryptoTools"><a class="docs-heading-anchor" href="#CryptoTools">CryptoTools</a><a id="CryptoTools-1"></a><a class="docs-heading-anchor-permalink" href="#CryptoTools" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/Maelstrom6/CryptoTools.jl">CryptoTools</a>.</p><ul><li><a href="#CryptoTools.DEFAULT_SECURITY"><code>CryptoTools.DEFAULT_SECURITY</code></a></li><li><a href="#CryptoTools.AES"><code>CryptoTools.AES</code></a></li><li><a href="#CryptoTools.Cipher"><code>CryptoTools.Cipher</code></a></li><li><a href="#CryptoTools.OneTimePad"><code>CryptoTools.OneTimePad</code></a></li><li><a href="#CryptoTools.SteamCipher"><code>CryptoTools.SteamCipher</code></a></li><li><a href="#Base.split-Tuple{ShamirSecretSharing, BigInt, Int64, Int64}"><code>Base.split</code></a></li><li><a href="#CryptoTools.decrypt"><code>CryptoTools.decrypt</code></a></li><li><a href="#CryptoTools.gmul-Tuple{UInt8, UInt8}"><code>CryptoTools.gmul</code></a></li><li><a href="#CryptoTools.pad"><code>CryptoTools.pad</code></a></li><li><a href="#CryptoTools.rijndael_key_schedule-Tuple{Vector{UInt8}, Any}"><code>CryptoTools.rijndael_key_schedule</code></a></li><li><a href="#CryptoTools.symmetric_key-Tuple{Int64}"><code>CryptoTools.symmetric_key</code></a></li><li><a href="#CryptoTools.unpad"><code>CryptoTools.unpad</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="CryptoTools.DEFAULT_SECURITY" href="#CryptoTools.DEFAULT_SECURITY"><code>CryptoTools.DEFAULT_SECURITY</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>The default number of byes of security (256-bit).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Maelstrom6/CryptoTools.jl/blob/2a13daddd2342e16cfd65ad4bab83156e0ef0ceb/src/CryptoTools.jl#L8-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryptoTools.AES" href="#CryptoTools.AES"><code>CryptoTools.AES</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The cipher key used for encryption is 128, 192 or 256 bits long.</p><p>If you want to encrypt only a single block of exactly 16 bytes, use padding=false.</p><p>Without KeyExpansion, all rounds would use the same key, K, and AES would be vulnerable to slide attacks. Without AddRoundKey, encryption wouldn’t depend on the key; hence, anyone could decrypt any ciphertext without the key. SubBytes brings nonlinear operations, which add cryptographic strength. Without it, AES would just be a large system of linear equations that is solvable using high-school algebra. Without ShiftRows, changes in a given column would never affect the other columns, meaning you could break AES by building four 232-element codebooks for each column. (Remember that in a secure block cipher, flipping a bit in the input should affect all the output bits.) Without MixColumns, changes in a byte would not affect any other bytes of the state. A chosen-plaintext attacker could then decrypt any ciphertext after storing 16 lookup tables of 256 bytes each that hold the encrypted values of each possible value of a byte.</p><p>You should never encrypt blocks independently. This reveals patterns and identical plaintext values because the ciphertext will be the same. This is called electronic codebook and should be avoided. One should rather use cipher block chaining.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Maelstrom6/CryptoTools.jl/blob/2a13daddd2342e16cfd65ad4bab83156e0ef0ceb/src/BlockCipher.jl#L177-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryptoTools.Cipher" href="#CryptoTools.Cipher"><code>CryptoTools.Cipher</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Cipher</code></pre><p>A cipher is an algorithm used to translate plaintext into ciphertext.</p><p><strong>Attack models</strong></p><p>Attack model - assumptions about what the attacker can and cannot do.</p><ol><li>Ciphertext-only attackers (COA) observe ciphertexts but don&#39;t know</li></ol><p>the associated plaintexts, and don&#39;t know how the plaintexts were selected. Attackers in the COA model are passive and can&#39;t perform encryption or decryption queries.</p><ol><li>Known-plaintext attackers (KPA) observe ciphertexts and do know the</li></ol><p>associated plaintexts. Attackers in the KPA model thus get a list of plaintext–ciphertext pairs, where plaintexts are assumed to be randomly selected. Again, KPA is a passive attacker model.</p><ol><li>Chosen-plaintext attackers (CPA) can perform encryption queries for</li></ol><p>plaintexts of their choice and observe the resulting ciphertexts. This model captures situations where attackers can choose all or part of the plaintexts that are encrypted and then get to see the ciphertexts. Unlike COA or KPA, which are passive models, CPA are active attackers, because they influence the encryption processes rather than passively eavesdropping.</p><ol><li>Chosen-ciphertext attackers (CCA) can both encrypt and decrypt; that</li></ol><p>is, they get to perform encryption queries and decryption queries. CDs could use this method since attackers can encrypt and decrypt but they want the key so that they can distribute CDs.</p><p><strong>Security models</strong></p><p>Security model - states that we consider a successful attack.</p><p>Intuitively, a cipher is secure if, even given a large number of plaintext– ciphertext pairs, nothing can be learned about the cipher’s behavior when applied to other plaintexts or ciphertexts.</p><p>In mathematical terms this means</p><ol><li>Indistinguishability (IND) - Ciphertexts should be indistinguishable</li></ol><p>from random strings. This is usually illustrated with this hypothetical game: if an attacker picks two plaintexts and then receives a ciphertext of one of the two (chosen at random), they shouldn’t be able to tell which plaintext was encrypted, even by performing encryption queries with the two plaintexts</p><ol><li>Non-malleability (NM) - Given a ciphertext C1 = E(K, P1), it should be</li></ol><p>impossible to create another ciphertext, C2, whose corresponding plaintext, P2, is related to P1 in a meaningful way.</p><p><strong>Combining the two</strong></p><p>Security notion - the combination of some security goal with some attack model. We&#39;ll say that a cipher achieves a certain security notion if any attacker working in a given model can&#39;t achieve the security goal. The notion is described as GOAL-MODEL.</p><p>Semantic security - IND-CPA. That is, ciphertexts shouldn&#39;t leak any information about plaintexts as long as the key is secret. To achieve IND-CPA security, encryption must return different ciphertexts if called twice on the same plaintext; otherwise, an attacker could identify duplicate plaintexts from their ciphertexts, contradicting the definition that ciphertexts shouldn&#39;t reveal any information.</p><p>Some relations</p><ul><li>IND-CCA implies IND-CPA</li><li>NM-CCA implies NM-CPA</li><li>NM-CPA implies IND-CPA</li></ul><p>So encryption often is randomised with R, some fresh random bits each time the system is called.</p><p>Kerckhoffs&#39;s principle - the security of a cipher should rely only on the secrecy of the key and not on the secrecy of the cipher.</p><p>Entropy = - sum over x of P(X=x)*lb(P(X=x)) The binary logarithm expresses the information in bits and yields integer values when probabilities are powers of two. Entropy is the level of surprise of the outcome.</p><p><strong>Mersenne Twister</strong></p><p>Why Mersenne Twister (MT) algorithm is insecure. Its internal state is an array, S, consisting of 624 32-bit words. This array is initially set to S1, S2, . . . , S624 and evolves to S2, . . . , S625, then S3, . . . , S626, and so on, according to this equation: S(k + 624) := S(k + 397) ⊕ A((Sk ∧ 0x80000000) ∨ (S(k + 1) ∧ 0xfffffff)) all instructions are bitwise and A is a function that transforms some 32-bit word, x, to (x &gt;&gt; 1), if x&#39;s most significant bit is 0, or to (x &gt;&gt; 1) ⊕ 0x9908b0df otherwise.</p><p>Notice in this equation that bits of S interact with each other only through XORs. The operators ∧ and ∨ never combine two bits of S together, but just bits of S with bits from the constants 0x80000000 and 0x7fffffff. This way, any bit from S625 can be expressed as an XOR of bits from S398, S1, and S2, and any bit from any future state can be expressed as an XOR combination of bits from the initial state S1, . . . , S624.</p><p>Because there are exactly 624 × 32 = 19,968 bits in the initial state (or 624 32-bit words), any output bit can be expressed as an equation with at most 19,969 terms (19,968 bits plus one constant bit). That’s just about 2.5 kilobytes of data. The converse is also true: bits from the initial state can be expressed as an XOR of output bits.</p><p>A cipher is informationally secure only if, even given unlimited computation time and memory, it cannot be broken. Computational security views a cipher as secure if it cannot be broken within a reasonable amount of time, and with reasonable resources such as memory, hardware, budget, energy, and so on.</p><p>Computational security is sometimes expressed in terms of two values t and epsilon. We then say that a cryptographic scheme is (t, ε)-secure if an attacker performing at most t operations - whatever those operations are - has a probability of success that is no higher than ε. We can conclude that a cipher with a key of n bits is at best (t, t/2^n)-secure, for any t between 1 and 2^n.</p><p>t-secure = (t, 1)-secure n-bit security = 2^n-secure Does not provide much information on the cost of the attack because the attacker can break the cipher with less than expected number of operations.</p><p>Confusion means that the input (plaintext and encryption key) undergoes complex transformations, and diffusion means that these transformations depend equally on all bits of the input.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Maelstrom6/CryptoTools.jl/blob/2a13daddd2342e16cfd65ad4bab83156e0ef0ceb/src/BlockCipher.jl#L5-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryptoTools.OneTimePad" href="#CryptoTools.OneTimePad"><code>CryptoTools.OneTimePad</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OneTimePad</code></pre><p>The one time pad is a symmetric block cipher and it is the most secure cipher but the most pointless. It requires a key the same size as the plaintext. It then produces a ciphertext the same length as the plaintext as well by XORing the key and plaintext. Decryption works exactly the same.</p><p>Keys should only be used one time otherwise an attacker will be able to determine <code>XOR(plaintext1, plaintext2)</code> by calculating <code>XOR(ciphertext1, ciphertext2)</code>. Further, if an attacker can identify <code>plaintext1</code> then they can calculate <code>plaintext2</code>.</p><p>As long as the key is random, the ciphertext will appear completely random because the XOR of a random key and a nonrandom plaintext appears random. The attacker can only identify the plaintext&#39;s length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Maelstrom6/CryptoTools.jl/blob/2a13daddd2342e16cfd65ad4bab83156e0ef0ceb/src/BlockCipher.jl#L136-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryptoTools.SteamCipher" href="#CryptoTools.SteamCipher"><code>CryptoTools.SteamCipher</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Stream ciphers produce a pseudorandom stream of bits called the keystream. The keystream is XORed to a plaintext to encrypt it and then XORed again to the ciphertext to decrypt it.</p><p>From a high-level perspective, there are two types of stream ciphers: stateful and counter based. Stateful stream ciphers have a secret internal state that evolves throughout keystream generation. Counter-based stream ciphers produce chunks of keystream from a key, a nonce, and a counter value.</p><p>A feedback shift register (FSR) is simply an array of bits equipped with an update feedback function, which I’ll denote as f. FSRs have a period. Linear feedback shift registers (LFSRs) are FSRs with a linear feedback function - namely, a function that’s the XOR of some bits of the state. To mitigate the insecurity of LFSRs, you can hide their linearity by passing their output bits through a nonlinear function before returning them to produce what is called a filtered LFSR. Nonlinear FSRs (NFSRs) are like LFSRs but with a nonlinear feedback function instead of a linear one. That is, instead of just bitwise XORs, the feedback function can include bitwise AND and OR operations.</p><pre><code class="language-none">Grain-128a combines NFSR and LFSR</code></pre><p>Salsa20 RC4</p><p>To be primitive, the polynomial must have the following qualities: The polynomial must be irreducible, meaning that it can’t be factorized; that is, written as a product of smaller polynomials. For example, X + X 3 is not irreducible because it’s equal to (1 + X)(X + X2): (1 + X)(X + X2) = X + X2 + X2 + X3 = X + X3 The polynomial must satisfy certain other mathematical properties that cannot be easily explained without nontrivial mathematical notions but are easy to test.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Maelstrom6/CryptoTools.jl/blob/2a13daddd2342e16cfd65ad4bab83156e0ef0ceb/src/StreamCipher.jl#L1-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.split-Tuple{ShamirSecretSharing, BigInt, Int64, Int64}" href="#Base.split-Tuple{ShamirSecretSharing, BigInt, Int64, Int64}"><code>Base.split</code></a> — <span class="docstring-category">Method</span></header><section><div><p>n is the number of shares. k is the threshold.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Maelstrom6/CryptoTools.jl/blob/2a13daddd2342e16cfd65ad4bab83156e0ef0ceb/src/SecretSharing.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryptoTools.decrypt" href="#CryptoTools.decrypt"><code>CryptoTools.decrypt</code></a> — <span class="docstring-category">Function</span></header><section><div><p>If you encrypted only a single block of exactly 16 bytes, use padding=false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Maelstrom6/CryptoTools.jl/blob/2a13daddd2342e16cfd65ad4bab83156e0ef0ceb/src/BlockCipher.jl#L276-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryptoTools.gmul-Tuple{UInt8, UInt8}" href="#CryptoTools.gmul-Tuple{UInt8, UInt8}"><code>CryptoTools.gmul</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Galois Field (256) Multiplication of two Bytes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Maelstrom6/CryptoTools.jl/blob/2a13daddd2342e16cfd65ad4bab83156e0ef0ceb/src/Utils.jl#L47-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryptoTools.pad" href="#CryptoTools.pad"><code>CryptoTools.pad</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Pads so that the length of the result is a multiple of block size in bytes. A block size of 10 represents 10 bytes that make up a single block.</p><p>Padding for block ciphers is specified in the PKCS#7 standard and in RFC 5652. Method can be</p><ul><li>:zero</li><li>:pkcs7</li><li>:iso</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Maelstrom6/CryptoTools.jl/blob/2a13daddd2342e16cfd65ad4bab83156e0ef0ceb/src/Utils.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryptoTools.rijndael_key_schedule-Tuple{Vector{UInt8}, Any}" href="#CryptoTools.rijndael_key_schedule-Tuple{Vector{UInt8}, Any}"><code>CryptoTools.rijndael_key_schedule</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Generate the subkeys for the AES encryption standard given a key.     https://embeddedsw.net/Cipher<em>Reference</em>Home.html     https://en.wikipedia.org/wiki/AES<em>key</em>schedule     https://cryptography.fandom.com/wiki/Rijndael<em>key</em>schedule</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Maelstrom6/CryptoTools.jl/blob/2a13daddd2342e16cfd65ad4bab83156e0ef0ceb/src/KeyGen.jl#L66-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryptoTools.symmetric_key-Tuple{Int64}" href="#CryptoTools.symmetric_key-Tuple{Int64}"><code>CryptoTools.symmetric_key</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">symmetric_key(bytes::Int64)</code></pre><p>Generates a symmetric key with the number of bytes given by <code>bytes</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Maelstrom6/CryptoTools.jl/blob/2a13daddd2342e16cfd65ad4bab83156e0ef0ceb/src/KeyGen.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryptoTools.unpad" href="#CryptoTools.unpad"><code>CryptoTools.unpad</code></a> — <span class="docstring-category">Function</span></header><section><div><p>This is not vulnerable to padded oracle attacks because it does not fail if the padding is invalid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Maelstrom6/CryptoTools.jl/blob/2a13daddd2342e16cfd65ad4bab83156e0ef0ceb/src/Utils.jl#L28-L31">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 16 June 2021 07:44">Wednesday 16 June 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
